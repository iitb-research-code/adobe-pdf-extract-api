# -*- coding: utf-8 -*-
"""pdf_to_adobe_api_to_hocr.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14FrbVl1Wh-wd7KPbIECJ_oTpILXgh1ed
"""

import logging
import os.path
import zipfile
import json
import shutil
from glob import glob
import subprocess
import sys
from adobe.pdfservices.operation.auth.credentials import Credentials
from adobe.pdfservices.operation.exception.exceptions import ServiceApiException, ServiceUsageException, SdkException
from adobe.pdfservices.operation.pdfops.options.extractpdf.extract_pdf_options import ExtractPDFOptions
from adobe.pdfservices.operation.pdfops.options.extractpdf.extract_renditions_element_type import ExtractRenditionsElementType
from adobe.pdfservices.operation.pdfops.options.extractpdf.extract_element_type import ExtractElementType
from adobe.pdfservices.operation.execution_context import ExecutionContext
from adobe.pdfservices.operation.io.file_ref import FileRef
from adobe.pdfservices.operation.pdfops.extract_pdf_operation import ExtractPDFOperation
import re
import shutil
import copy
import PyPDF2

def removelink(filename):
    pdf_reader = PyPDF2.PdfFileReader(filename)
    pdf_writer = PyPDF2.PdfFileWriter()
    annotsPresent = False
    for i in range(pdf_reader.getNumPages()):
        page = pdf_reader.getPage(i)
        if '/Annots' in page:
            annotsPresent = True
            break
    if not annotsPresent:
        return

    for i in range(pdf_reader.getNumPages()):
        page = pdf_reader.getPage(i)
        if '/Annots' in page: 
            del page['/Annots']
        pdf_writer.addPage(page)

    with open('temp.pdf', 'wb') as f:
        pdf_writer.write(f)
    os.remove(filename)
    os.rename('temp.pdf', filename)

# removelink(sys.argv[1])
pdf_path = sys.argv[1]
set_directory = sys.argv[2]
page_offset = int(sys.argv[3])
num_pages = int(sys.argv[4])

#setup
logging.basicConfig(level=os.environ.get("LOGLEVEL", "INFO"))
# get base path.
base_path = './..'


# pdf_path = "jpg2pdf.pdf" 

# Initial setup, create credentials instance.
credentials = Credentials.service_account_credentials_builder() \
      .from_file(base_path + "/pdfservices-api-credentials.json") \
      .build()
      # .from_file(base_path + "/pdfservices-api-credentials.json") \


# Create an ExecutionContext using credentials and create a new operation instance.
execution_context = ExecutionContext.create(credentials)
extract_pdf_operation = ExtractPDFOperation.create_new()

# Set operation input from a source file.
# source = FileRef.create_from_local_file(base_path + "input/english_input0.pdf")
source = FileRef.create_from_local_file(pdf_path)
extract_pdf_operation.set_input(source)

# Build ExtractPDF options and set them into the operation
extract_pdf_options: ExtractPDFOptions = ExtractPDFOptions.builder() \
        .with_elements_to_extract([ExtractElementType.TEXT, ExtractElementType.TABLES]) \
        .with_elements_to_extract_renditions([ExtractRenditionsElementType.TABLES,
                                              ExtractRenditionsElementType.FIGURES]) \
        .build()
extract_pdf_operation.set_options(extract_pdf_options)

# Execute the operation.
result: FileRef = extract_pdf_operation.execute(execution_context)

#Delete source file to avoid overwriting or else PyPDF2 issue is raised
#os.remove(pdf_path)

# Save the result to the specified location.
try:
    result.save_as(base_path + "/output/ExtractTextTableWithFigureTableRendition.zip")
    zip_file_name = base_path + "/output/ExtractTextTableWithFigureTableRendition.zip"
except:    
    for f in glob("/tmp/extractSdkResult/*"):
        print(f)
        zip_file_name = f
        # shutil.move(f, "layout_files/output")
        # subprocess.run(["mv", f, "layout_files/output/"])
        # os.rename(f,"layout_files,output/" + f[f.rindex("/")+1:])
print("Page Offset",page_offset, "Type", type(page_offset))
if page_offset>0:
    with zipfile.ZipFile(zip_file_name,"r") as zip:
        zip.extractall(set_directory + "/Cropped_Images"+str(page_offset))
    print(set_directory + "/Cropped_Images"+str(page_offset))
    print(os.path.exists(set_directory + "/Cropped_Images"+str(page_offset)))
else:
    with zipfile.ZipFile(zip_file_name,"r") as zip:
        zip.extractall(set_directory + "/Cropped_Images")
#converting json output into 
for f in glob("/tmp/extractSdkResult/*"):
    os.remove(f)

if page_offset>0:
    json_file = set_directory + "/Cropped_Images"+str(page_offset)+"/structuredData.json"
else:
    json_file = set_directory + "/Cropped_Images/structuredData.json"

for f in glob("layout_files/output/*"):
    os.remove(f)
f = open(json_file)
data = json.load(f)
if page_offset==0:
    os.remove(set_directory + "/Cropped_Images/structuredData.json")
# shutil.rmtree("result")

if page_offset>0:
    if os.path.exists(set_directory + "/Cropped_Images"+str(page_offset)+"/figures"):
        shutil.move(set_directory +"/Cropped_Images"+str(page_offset)+"/figures",set_directory +"/Cropped_Images/figures"+str(page_offset+1))
    if os.path.exists(set_directory + "/Cropped_Images"+str(page_offset)+"/tables"):
        shutil.move(set_directory +"/Cropped_Images"+str(page_offset)+"/tables",set_directory +"/Cropped_Images/tables"+str(page_offset+1))
    shutil.rmtree(set_directory +"/Cropped_Images"+str(page_offset))

def clean_text(string):
  subs = re.findall("\(<http[^>)]*>\)|<http[^>]*>",string)
  for sub in subs:
    string = string.replace(sub,"")
  return string

def conv_bbox(bounds,page_dim):
  bbox = copy.deepcopy(bounds)
  # if element['Page']>6:
  #   print(element)
  y_start = page_dim[1]-bbox[3]
  y_end = page_dim[1]-bbox[1]
  bbox[1] = y_start
  bbox[3] = y_end
  final_bbox = [int(i*300/72) for i in bbox]
  return final_bbox

def table_hocr(table, table_box):
  hocr = f'<table class="ocr_tab" title="bbox {" ".join([str(coord) for coord in table_box])}"> \n'
  for row in table:
    hocr +="<tr> \n"
    for cell in row:
      cell_hocr = ""
      if cell[1]:
        cell_hocr = f'      <td title="bbox {" ".join([str(coord) for coord in cell[2]])}"> \n'
      else:
        cell_hocr = f'      <th title="bbox {" ".join([str(coord) for coord in cell[2]])}"> \n'
      # print(cell[0])
      for contents in cell[0]:
        if contents[0]=='Text':
          cell_hocr += '          '+contents[2] + ' \n'
        elif contents[0]=='Figure':
          if page_offset > 0:
            index = str(page_offset + 1) + "/"
            content = list(contents)
            print("Offset > 0")
            print(content)
            img_path = content[2].replace('/', index, 1)
          else:
            img_path = contents[2]
          cell_hocr += f'          <img class="ocr_im" title="bbox {" ".join([str(coord) for coord in contents[1]])}" src="../Cropped_Images/{img_path}"> \n'
      
      if cell[1]:
        cell_hocr += "      </td> \n"
      else:
        cell_hocr += "      </th> \n"

      hocr += cell_hocr
    hocr +="</tr> \n"
  hocr += "</table> \n"
  return hocr

def figure_path(path,offset):
    if offset >0:
        fig_ind = path.find("figures")
        fig_path = path[:fig_ind]+"figures"+str(offset + 1)+path[fig_ind+len("figures"):]
        return fig_path
    else:
        return path

def gen_tables(elements,page_dims):
  table_data = [element for element in elements if "Table" in element['Path']]
  tables = {}
  # if "Page" not in element:
  #   return tables
  table_names = []
  for element in elements:
    if "Table" in element['Path'].split("/")[-1] and "Page" in element:
      table_names.append((element['Page'],element['Path'],element['Bounds']))
  # table_names = [(element['Page'],element['Path'],element['Bounds']) for element in elements if "Table" in element['Path'].split("/")[-1] and if "Page" in element]
  # print(table_names)
  for pg,table,bound in table_names:
    tables[table] = {'page': pg, "tab": [], "hocr": [], "bbox": conv_bbox(bound,page_dims[pg]),"added": []}

  # print(tables)
  for pg,table,bound in table_names:
    # print(pg,table)
    tab = []
    res = [element['Path'].split("/")[-2] for element in elements if "TR" in element['Path'].split("/")[-2] and table == "/".join(element['Path'].split("/")[:-2]) ]
    # trs = list(set(trs))
    # trs.sort()
    trs = []
    [trs.append(x) for x in res if x not in trs]
    # print(trs)

    for tr in trs:
      row = []
      ths = [element['Path'] for element in elements if "TH" in element['Path'].split("/")[-1] and table == "/".join(element['Path'].split("/")[:-2]) and tr == element['Path'].split("/")[-2] ]  
      # if len(ths)!=0:
      #   print(ths)
      
      tds = [element['Path'] for element in elements if "TD" in element['Path'].split("/")[-1] and table == "/".join(element['Path'].split("/")[:-2]) and tr == element['Path'].split("/")[-2] ]
      # if len(tds)!=0:
      # print(tds)

      # For table headers
      for th in ths:
        th_cont = []
        thbbox = []
        for element in elements: 
          if th+'/' in element['Path'] :
            if 'Bounds' in element:
              bbox = conv_bbox(element["Bounds"],page_dims[element['Page']])
              if 'Text' in element:
                  th_cont.append(("Text",[int(i) for i in bbox],element['Text'],element['Page']))
              if 'Figure' in element['Path']:
                  th_cont.append(("Figure",[int(i) for i in bbox],element['filePaths'][0],element['Page']))
          elif th ==element['Path']:
            if "Bounds" in element:
                bbox = conv_bbox(element["Bounds"],page_dims[element['Page']])
                thbbox = conv_bbox(element["Bounds"],page_dims[element['Page']])
            if 'Text' in element:
                th_cont.append(("Text",[int(i) for i in bbox],element['Text'],element['Page']))
        row.append((th_cont,False,thbbox))

      # For table data
      for td in tds:
        td_cont = []
        tdbbox = []
        for element in elements:
          if td+'/' in element['Path'] :
            if 'Bounds' in element:
              bbox = conv_bbox(element["Bounds"],page_dims[element['Page']])
              if 'Text' in element:
                  td_cont.append(("Text",[int(i) for i in bbox],element['Text'],element['Page']))
              if 'Figure' in element['Path']:
                  td_cont.append(("Figure",[int(i) for i in bbox],element['filePaths'][0],element['Page']))
          elif td ==element['Path']:
            if 'Bounds' in element:
              bbox = conv_bbox(element["Bounds"],page_dims[element['Page']])
              tdbbox = conv_bbox(element["Bounds"],page_dims[element['Page']])
              # print("TD BBOX",tdbbox)
              if 'Text' in element:
                  td_cont.append(("Text",[int(i) for i in bbox],element['Text'],element['Page']))
        row.append((td_cont,True,tdbbox))
      tab.append(row)
    tables[table]['tab'] = tab
  return tables

def table_splitter(table,pg):
  page = pg
  pg_tables = []
  pg_table = []
  for row in table:
    # print(row[0][0][0][-1],page)
    for cell in row:
      # print(cell)
      if len(cell[0])==1 and len(cell[0][0]) == 4:
        if cell[0][0][-1]==page:
          pg_table.append(row)
        elif cell[0][0][-1]==page+1:
          pg_tables.append(pg_table)
          pg_table = [row]
          page += 1
        break
  if pg_table not in pg_tables:
    pg_tables.append(pg_table)
  return pg_tables



# Converting json output into HOCR
import copy
elements = copy.deepcopy(data['elements'])
page_props = data["pages"]
elements = data['elements']
page_props = data["pages"]

# Creating dictionaries for pages and their dimensions
num_pages = data["extended_metadata"]["page_count"]
pages = {}
page_dims = {}
for i in range(num_pages):
  pages[i]=[]
  page_dims[i] = (int(page_props[i]["width"]), int(page_props[i]["height"]))


# Generating tables and their hocrs
tables = gen_tables(elements,page_dims)
for table in tables:
  # print(tables[table]['tab'][0][1][0][0][-1])
  pg_tables = table_splitter(tables[table]['tab'],tables[table]['page'])
  # print(len(pg_tables))
  pg = tables[table]['page']
  for pg_table in pg_tables:
    tables[table]['hocr'].append(table_hocr(pg_table,tables[table]['bbox']))
    tables[table]['added'].append(False)


# Segregating elements pagewise
for element in elements:
  if 'Bounds' in element:
    bbox = conv_bbox(element["Bounds"],page_dims[element['Page']])
    if "Table" in element['Path']:
      for table in tables:
        for h in range(len(tables[table]['hocr'])):
          # tables[table] = {'page': pg, "tab": [], "hocr": "", "bbox": conv_bbox(bound,page_dims[pg]),"added": False}
          # print(table, tables[table]['page'], tables[table]['added'])
          # print(element['Path'], element['Page'])
          if table in element['Path'] and tables[table]['page']+h==element['Page'] and not tables[table]['added'][h]:  
            pages[element['Page']].append(('Table',tables[table]['hocr'][h]))
            tables[table]['added'][h] = True
      # print("Table")
    elif 'Text' in element.keys():
      pages[element['Page']].append(('Text',[int(i) for i in bbox],element['Text']))
    elif "Figure" in element['Path'].split("/")[-1]:
      pages[element['Page']].append(("Figure",[int(i) for i in bbox],element['filePaths'][0]))
      # print("Figure")

hocrs = []

# HOCR Generation for each page
for page in pages:
  header = f'''
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
      <title>
      </title>
      <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
      <meta content="tesseract 5.0.0-alpha-20201231-256-g73a32" name="ocr-system"/>
      <meta content="ocr_page ocr_carea ocr_par ocr_line ocrx_word ocrp_wconf" name="ocr-capabilities"/>
    </head>
    <body>
      <div class="ocr_page" id="page_id_{page_offset*100+page}" title='page "{page_offset*100+page}"; bbox 0 0 {page_dims[page][0]} {page_dims[page][1]} ppageno 0'>
    '''
  footer = "    </div>\n  </body>\n</html>"
  hocr=""
  hocr+=header
  for element in pages[page]:
    if element[0]=="Text":
      hocr += f'      <span class="ocr_sent" title="bbox {" ".join([str(i) for i in element[1]])}">{element[2]}</span>\n'
    if element[0]=="Table":
      hocr += element[1]
    if element[0]=="Figure":
      img_path = element[2]
      if page_offset > 0:
        index = str(page_offset + 1) + "/"
        img_path = img_path.replace('/', index, 1)
      hocr += f'      <img class="ocr_im" title="bbox {" ".join([str(i) for i in element[1]])}" src="../Cropped_Images/{img_path}"> \n'
  hocr+=footer
  hocrs.append(hocr)

# Saving hocr files
n = len(hocrs)
for i in range(n):
    pg_num = page_offset*100+i
    file_name = "p-"+("0"*(len(str(num_pages))-len(str(pg_num+1)))) + str(pg_num+1) + ".hocr"
    if not os.path.exists(set_directory+"/Inds/"):
      os.mkdir(set_directory+"/Inds/")
    f = open(set_directory+"/Inds/" + file_name, "w")
    f.write(hocrs[i])
    f.close()
